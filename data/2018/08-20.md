# Javascript里的浮点数

今天做需求的时候碰到一个之前从未注意过的小问题，在这里记录一下

假设有一段代码是这样的：

```
if (0.4+0.3+0.2+0.1 == 1) {
    // do something...
}
```

你满心希望这个判断条件可以让你do something，但是……结果是你永远进不到这个if里面

这个就很恐怖了，于是你打算检查一下

` console.log(0.4+0.3+0.2+0.1)`

好的，结果是0.9999999999999999

**那么这是为什么呢！下面是揭秘环节！**

---

我们知道，JS里所有数字，无论整型还是浮点，都是`Number`格式，即IEEE754标准里的64位二进制浮点数。

看到这里应该一些学过计组的同学就会大概明白原因了，这里再举一个通俗一点的例子

Q：十进制浮点小数是怎么转化为二进制的呢？

A：对十进制小数乘2得到的整数部分和小数部分，整数部分既是相应的二进制数码，再用2乘小数部分（之前乘后得到新的小数部分），又得到整数和小数部分。如此不断重复,直到小数部分为0或达到精度要求为止。

所以我们知道，十进制小数转成二进制时，**除非十进制小数是1/2^n**，那么，转化所得的二进制小数必然是一个**近似的无限小数**！

又因为64位的精度限制，导致这个近似的小数会被截断，造成精度上的损失，进而导致计算结果的偏差

那么，解决方案就很简单啦，只需要限定输出结果的精度就可以了～

**Solution:**

```
// Number.toPrecision()设定了浮点数精确到小数点后第几位
if (parseFloat((0.4+0.3+0.2+0.1).toPrecision(10)) == 1) {
    // do something...
}
```